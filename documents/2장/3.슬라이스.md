# 슬라이스(Slices)

</br>

소유권을 갖지 않는 또다른 데이터 타입은 슬라이스이다.

슬라이스는 컬렉션(collection)전체가 아닌 컬렉션의 연속된 일련의 요소들을 참조할 수 있게 해준다.

</br>

String을 입력 받아 그 String에서 찾은 첫번째 단어를 반환하는 함수를 작성한다. 만일 함수가 공백문자를 찾지 못한다면, 이는 전체 스트링이 한 단어란느 의미이고, 이 때는 전체 스트링이 반환되어야 한다.

이 함수의 시그니처에 대해 생각해보면 

``` rs
fn first_word(s: &String) -> ?
```

위 코드는 반환에 문제가 생기는데 스트링의 일부에 대해 표현할 방법이 없다. 하지만 단어의 끝 부분의 인덱스를 반환할 수는 있다.

</br>

<strong>FileName : 2장/slices_task/src/main.rs</strong>

``` rs
fn main(){
    let s = String::from("hello world!");

    let len = first_word(&s);

    println!("len: {}",len);
}   

fn first_word(s: &String) -> usize{
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate(){
        if item == b' '{
            return i;
        }
    }
    s.len()
}



❯ cargo run
   Compiling slices_task v0.1.0 (/home/PromotionPawn/Project/Rust/2장/slices_task)
    Finished dev [unoptimized + debuginfo] target(s) in 2.88s
     Running `target/debug/slices_task`
len: 5
```

String 파라미터의 바이트 인덱스 값을 반환하는 first_word 함수

</br>

입력된 String을 요소별로 보면 그 값이 공백인지 확인할 필요가 있기 때문에, String은 as_bytes 메소드를 이용해 바이트 배열로 변환된다.

``` rs
let bytes = s.as_bytes();
```

</br>

다음으로 iter 메소드를 이용하여 바이트 배열의 반복자(iterator)를 생성한다.

``` rs
for (i, &item) in bytes.iter().enumerate(){
```

iter는 컬렉션의 각 요소를 반환하는 함수이며, enumerate는 iter의 결과값을 직접 반환하는 대신 이를 감싸서 튜플의 일부로 만들어 반환한다.

반환된 튜플의 첫번째 요소는 인덱스 이며, 두번째 요소는 요소에 대한 참조값이다.

enumerate 메소드가 튜플을 반환하기 때문에, 러스트의 다른 모든 부분에서 그러하듯이 이 튜플을 해체하기 위해 패턴을 이용할 수 있다. 따라서 for 루프 내에서, i는 튜플 내의 인덱스에 대응하고 &item은 튜플 내의 한 바이트에 대응하는 패턴을 기술한 것이다.

.iter().enumerate()의 요소에 대한 참조자를 갖는 것으로, &를 패턴 내에 사용했다.

</br>

바이트 리터럴 문법을 이용하여 공백 문자를 나타내는 바이트를 찾는다. 공백 문자를 찾았다면, 이 위치를 반환한다. 그렇지 않으면 s.len()을 통해 String의 길이값을 반환한다.

</br>

``` rs
    if item == b' '{
        return i;
    }
}
s.len()
```

이제 String 첫번째 단어의 끝부분의 인덱스를 찾아낼 방법이 생겼다. usize를 그래도 반환하고 있지만, 이는 &string의 내용물 내에서만 의미가 있다. 즉 이것이 String으로부터 분리되어 있는 숫자이기 때문에, 이것이 나중에도 여전히 유효한지 보장할 길이 없다.

</br>

``` rs
fn main(){
    let mut s = String::from("hello world");
    
    // word는 5를 갖게된다.
    let word = first_word(&s);

    //이 코드는 String을 비워 ""로 만든다.
    s.clear()

    // word는 여기서 여전히 5를 갖고 있지만, 
    // 5라는 값을 의미있게 쓸 수 있는 String은 존재하지 않는다.
}   // word는 이제 완전 유효하지 않다.
```

first_word 함수를 호출하여 결과를 저장한 뒤 String의 내용물 바꾸기 

</br>

위 프로그램은 아무런 오류 없이 컴파일되고, s.clear()을 호출한 뒤 word를 사용한다 해도 역시 컴파일될것이다.

word는 s의 상태와 전혀 연결되어 있지 않으므로, word는 여전히 값 5를 담고 있다.

첫번째 단어를 추출하고자 하기 위해 s와 값 5를 사용할 수 있지만, word에 5를 저장한 뒤 s의 내용물이 변경되었기 때문에 이러한 사용은 버그가 될 것이다.

word의 인덱스가 s의 데이터와 싱크가 안맞을 것을 걱정하는건 지겹고 쉽게 발생할 수 있는 오류이다.

이러한 인덱스들을 관리하는 것은 second_word함수를 작성했을 때 더더욱 다루기 어려워 진다.

``` rs
fn second_word(s: &String) -> (usize, usize) {
```

</br>

이제 시작, 그리고 끝 인덱스를 추적하고 있고, 특정 상태에 있는 데이터로부터 계산되었지만 그 상태와 전혀 묶여 있지 않은 더 많은 값들을 갖게 된다.

이제 동기화를 유지할 필요가 있는 주위를 떠다니는 세개의 관련 없는 변수들을 갖게 되었다.

운좋게도 Rust는 이러한 문제에 대한 해결책으로 스트링 슬라이스(string slice)를 갖고 있다.

</br>
</br>
</br>

## 스트링 슬라이스 
