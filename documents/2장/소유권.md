# 소유권 이해하기 

</br>

소유권(Ownership)은 Rust의 가장 유니크한 특성이며, 러스트가 가비지 콜렉터 없이 메모리 안정성 보장을 하게 해준다.

그러므로, 소유권이 러스트 내에서 어떻게 동작하는지 이해하는 것이 중요하다. 이 장에서는 소유권 뿐만 아니라 빌림, 슬라이스, 그리고 Rust가 메모리에 데이터를 저장하는지 등을 학습한다.

</br>
</br>
</br>

## 소유권이 뭔가요?

</br>

Rust의 핵심 기능은 바로 소유권이다. 모든 프로그램은 실행하는 동안 컴퓨터의 메모리를 사용한느 방법을 관리해야 한다. 몇몇 언어들은 프로그램이 실행될 때 더이상 사용하지 않는 메모리를 끊임없이 찾는 가비지 콜렉션을 갖고 있다. 다른 언어들에서는 프로그래머가 직접 명시적으로 메모리를 할당하고 해제해야 한다. 

Rust는 제 3의 접근법을 이용한다. 

메모리는 컴파일 타임에 컴파일러가 체크할 규칙들로 구성된 소유권 시스템을 통해 관리된다. 소유권 기능들의 어떤 것도 런타임 비용이 발생하지 않는다. 

</br>
</br>
</br>

## 스택과 힙 

많은 프로그래밍 언어들 안에서, 그렇게 자주 스택과 힙에 대한 생각을 할 필요가 없다. 그렇지만 러스트와 같은 시스템 프로그래밍 언어에서는, 값이 스택에 있는지 힙에 있는지 여부가 언어의 동작 방식과 결단에 큰 영향을 준다.

스택과 힙 둘다 코드상에서 런타임에 사용할 수 있는 메모리 부분이지만 이들은 각기 다른 방식으로 구조화 되어 있다. 스택은 받아들인 순서대로 값을 저장하고 반대 방향으로 값을 지운다. 이것을 last in first out 이라고 한다. 데이터를 추가하는 것을 스택에 푸시하기 (pushing on the stack)라 부르고, 데이터를 제거하는 것을 스택을 팝하기(popping off the stack)라고 부른다.

스택은 데이터에 접근하는 방식 덕택에 빠르다. 이 방식은 새로운 데이터를 넣어두기 위한 공간 혹은 데이터를 가져올 공간을 검색할 필요가 전혀 없는데, 바로 그 공간이 항상 스택의 꼭대기(top)이기 때문이다. 

스택을 빠르게 해주는 또다른 특성은 스택에 담긴 모든 데이터가 결정되어 있는 고정된 크기를 갖고있어야 한다는 점이다. 

컴파일 타임에 크기가 결정되어 있지 않거나 크기가 변경될 수 있는 데이터를 위해서는, 힙에 데이터를 저장할 수 있다. 

힙은 조금 더 복잡한데 데이터를 힙에 넣을때, 먼저 자장할 공간이 있는지 물어본다. 그러면 운영체제가 충분히 커다란 힙 안의 빈 어떤 지점을 찾아서 이곳을 사용중이라고 표시하고, 해당 지점의 포인터를 우리에게 돌려준다. 이 절차를 힙 공간 할당하기(allocating on the heap)라고 부른다. 

스택에 포인터를 푸싱하는 것은 할당에 해당되지 않는다. 포인터는 결정되어 있는 고정된 크기의 값이므로, 스택에 포인터를 저장할 수 있지만, 실제 데이터를 사용하고자 할 때는 포인터를 따라가야 한다. 

힙에 저장된 데이터에 접근하는 것은 스택에 저장된 데이터에 접근하는 것보다 느린데, 그 이유는 포인터가 가리킨 곳을 따라가야하기 때문이다. 현대 프로세서들은 메모리 내부를 덜 뛰어나닐 때 더 빨라진다.

코드의 어느 부분이 힙의 데이터를 사용하는지 추적하는 것, 힙의 중복된 데이터의 양을 최소화하는 것, 그리고 힙 내에 사용하지 않는 데이터를 제거하여 공간이 모자라지 않게 하는 것은 모두 소유권과 관계된 문제들 이다. 


</br>
</br>
</br>

## 소유권 규칙 

</br>

소유권 규칙 

-----

1. 러스트의 각각의 값은 해당값의 오너라고 불리우는 변수를 갖고 있다. 

2. 한번에 딱 하나의 오너만 존재할 수 있다.

3. 오너가 스코프 밖으로 벗어나는 때, 값은 버려진다(dropped)

----

</br>
</br>

## 변수의 스코프 

``` rs
{   // s는 유효하지 않다. 아직 선언이 안됐기 때문
    let s = "hello";   // s는 이 지점부터 유효
    // s를 가지고 뭔가 함
}   // 이 스코프 밖으로 나가는 순간 s는 더이상 유효하지 않음 
```

위 코드에서는 중요한 지점이 있는데 

1. 스코프 안에서 s가 등장하면 유효

2. 이 유효기간은 스코프 밖으로 벗어날 때 까지 지속 

이 지점에서, 스코프와 변수가 유효한 시점 간의 관계는 다른 프로그래밍 언어와 비슷하다. 


</br>
</br>
</br>

## String 타입

이전의 모든 데이터 타입은 스택에 저장되었다가 스코프를 벗어날 때 스택으로부터 팝 되지만 지금부터는 힙에 저장된느 데이터를 관찰하고 Rust는 과연 어떻게 이 데이터를 비워내는지 설명할 필요가 있다.

스트링 리터럴를 이미 봤는데, 이 값은 프로그램 안에 하드코딩 되어 있다. 문자열 값은 편리하지만 텍스트를 필요로 하는 모든 경우에 대해 항상 적절하진 않다. 

그 중 한가지 이유로, 문자열 값은 불변이다. 또다른 이유는 모든 문자열이 우리가 프로그래밍 하는 시점에 다 알수 있는 것이 아니란 점이다. 

예를 들어 사용자의 입력을 받고싶다면?

이러한 경우들에 대해서 Rust는 두번째 문자열 타입인 String을 제공한다. 이 타입은 힙에 할당되고 따라서 컴파일 타임에는 우리가 알 수 없는 양의 텍스트를 저장할 수 있다. 

아래 코드는 스트링 리터럴로부터 from이라는 함수를 이용해서 String을 아래처럼 만들 수 있다 

``` rs
let s = String::from("hello");
```

더블 콜론(::)은 우리가 string_from과 같은 이름을 쓰기 보다는 String타입 아래의 from함수를 특정지을 수 있도록 해주는 네임스페이스 연산자 이다.

이러한 종류의 문자열은 변경 가능하다 

</br>
</br>
</br>

``` rs
let mut s = String::from("hello");

//push_str()은 해당 스트링 리터럴을 스트링에 붙여준다.
s.push_str(", world!");


// 'hello, world!' 출력
println!("{}", s);
```
왜 String은 변할 수 있는데 스트링 리터럴은 안되는 것일까? 차이점은 두 타입이 메모리를 쓰는 방식에 있다.


</br>
</br>
</br>

## 메모리와 할당 

</br>

스트링 리터럴의 경우, 내용뮬을 컴파일 타임에 알 수 있으므로 텍스트가 최종 실행파일에 직접 하드코딩 되었고, 이렇게 하면 스트링 리터럴이 빠르고 효율적이다.

그러나 이 문자열이 변경되지 않는 것을 전재로 하는 특성이다. 

이렇게 하면 컴파일 타임에 크기를 알 수 없는 경우 및 실행 중 크기가 변할 수도 있는 경우의 텍스트 조각을 바이너리 파일에 집어넣을 수 없다.

</br>

String타입은 변경 가능하고 커질 수 있는 텍스트를 지원하기 위해 만들어졌고, 힙에서 컴파일 타임에는 알 수 없는 어느 정도 크기의 메모리 공간을 할당받아 내용물을 저장할 필요가 있다. 

즉 이는 다음을 의미한다. 

---

1. 런타임에 운영체제로부터 메모리가 요청되어야 한다. 

2. String의 사용이 끝났을 때 운영체제에게 메모리를 반납할 방법이 필요하다 

---

첫번째는 직접 수행한다. String::from을 호출하면, 구현부에서 필요한 만큼의 메모리를 요청한다. 이는 프로그래밍 언어들 사이에서 매우 일반적이다. 

하지만 두번째는 다르다. 가비지 콜렉터를 갖고 있는 언어들의 경우, CG가 더이상 사용하지 않는 메모리 조각을 계속해서 찾고 지워주며, 프로그래머로서 이와 관련한 생각을 안해도 된다. CG가 없을 경우, 할당 받은 메모리가 더이상 필요없는 시점을 알아서 명시적으로 이를 반납하는 코드를 호출하는 것은 프로그래머의 책임이다. 

딱한번의 allocate와 한번의 free쌍을 사용해야 한다. 

러스트는 다른 방식으로 이 문제를 다룬다. 메모리는 변수가 소속되어 있는 스코프 밖으로 벗어나는 순간 자동으로 반납된다. 

``` rs
{ 
    let s = String::from("hello");  // s는 여기서부터 유효

    // s를 가지고 뭔가 함
}   // 스코프 밖으로 나가는 순간 s는 더이상 유효하지 않음 
```

String이 요구한 메모리를 운영체게에게 반납하는 자연스로운 지점이 있는데, s가 스코프 밖으로 벗어날 때 이다. 변수가 스코프 밖으로 벗어나면, Rust는 drop이라는 특별한 함수를 호출한다. 

String의 개발자가 메모리를 반환하도록 하는 코드를 집어넣을 수 있다. 러스트는 } 괄호가 닫힐때 자동적으로 drop을 호출한다 

---

이 패턴은 러스트 코드가 작성되는 방법에 깊은 영향을 준다. 힙에 할당시킨 데이터를 사용하는 여러개의 변수를 사용하고자 할 경우와 같이 좀더 복잡한 상황에서, 코드의 동작은 예기치 못할 수 있다. 

</br>
</br>
</br>

## 변수와 데이터가 상호작용하는 방법: 이동(move)

</br>

여러개의 변수들은 러스트에서 서로 다른 방식으로 같은 데이터에 대해 상호작용할 수 있다. 

``` rs
//변수 x의 정수값을 y에 대입
let x = 5;
let y = x;
```

</br>

아마도 다른 언어들에서의 경험을 토대로 어떤 일이 벌어지는지 추측할 수 있다. 정수값 5를 x에 묶어놓고; x의 값의 복사본을 만들어 y에 묶는다. 이제 x와 y 두 개의 변수를 갖게 되었고, 둘 다 5와 같다. 정수값이 결정되어 있는 고정된 크기의 단순한 값이고, 5라는 값들이 스택에 푸쉬되기 때문에, 실제로도 이렇게 된다.

</br>
</br>

String 버전 

``` rs
let s1 = String::from("hello");
let s2 = s1;
```

</br>

위 코드는 이전의 코드와 매우 유사해 보여서, 동작하는 방식도 동일할 것이라 생각하겠지만 실제론 생각과 다르게 동작한다. 

String은 그림의 왼쪽과 같이 세 개의 부분으로 이루어져 있다. 문자열의 내용물을 담고 있는 메모리의 포인터, 길이, 그리고 용량이다. 이 데이터의 그룹은 스택에 저장된다. 내용물을 담은 오른쪽의 것은 힙 메모리에 있다. 

</br>

 s1     
| name | value |
| :---:| :----:|
| ptr  |    -> 0| 
| len  |   5   |
| capacity| 5  |

</br>
</br>

| index | value |
| :---:| :----: |
| 0    |   h    | 
| 1    |   e    |
| 2    |   l    |
| 3    |   l    |
| 4    |   o    |

s1 변수에 "hello" 값이 저장된 String의 메모리 구조

</br>

길이값은 바이트 단위로 String의 내용물이 얼마나 많은 메모리를 현재 사용하고 있는지를 말한다. 용량값은 바이트 단위로 String이 운영체제로부터 얼마나 많은 양의 메모리를 할당 받았는지를 말한다.

</br>

s2에 s1을 대입하면, String 데이터가 복사되는데, 이는 스택에 있는 포인터, 길이값, 그리고 용량값이 복사된다는 의미이다. 포인터가 가리키고 있는 힙 메모리 상의 데이터는 복사되지 않는다. 

</br>

그림 4-4

s1     
| name | value |
| :---:| :----:|
| ptr  |    -> 0| 
| len  |   5   |
| capacity| 5  |

</br>
</br>

| index | value |
| :---:| :----: |
| 0    |   h    | 
| 1    |   e    |
| 2    |   l    |
| 3    |   l    |
| 4    |   o    |

</br>
</br>

s2
| name | value |
| :---:| :----:|
| ptr  |    -> 0| 
| len  |   5   |
| capacity| 5  |

</br>

s1의 포인터, 길이값, 용량값이 복사된 s2 변수의 메모리 구조 

</br>
</br>

메모리 구조는 아래 그림과 같지 않은데 아래 그림은 러스트가 힙 메모리 상의 데이터까지도 복사한다면 벌어질 일이다. 만일 러스트가 이렇게 동작한다면, 힙 안의 데이터가 클 경우 s2 = s1 연산은 런타임 상에서 매우 느려질 가능성이 있다.

</br>

s1     
| name | value |
| :---:| :----:|
| ptr  |    -> 0| 
| len  |   5   |
| capacity| 5  |

</br>
</br>

| index | value |
| :---:| :----: |
| 0    |   h    | 
| 1    |   e    |
| 2    |   l    |
| 3    |   l    |
| 4    |   o    |

</br>
</br>

s2
| name | value |
| :---:| :----:|
| ptr  |    -> 0| 
| len  |   5   |
| capacity| 5  |

</br>
</br>

| index | value |
| :---:| :----: |
| 0    |   h    | 
| 1    |   e    |
| 2    |   l    |
| 3    |   l    |
| 4    |   o    |


</br>
</br>
</br>

---

</br>

앞서 변수가 스코프 밖으로 벗어날 때, 러스트는 자동적으로 drop 함수를 호출하여 해당 변수가 사용하는 힙 메모리를 제거한다고 했다. 

하지만 그림 4-4에서는 두 데이터 포인터가 모두 같은 곳을 가리키고 있는다. 이는 곧 문제가 되는데 s1과 s2가 스코프 밖으로 벗어나게 되면, 둘 다 같은 메모리를 해제 하려 할것이다. 이는 두번 해제 (double free) 오류라고 알려져 있으며 이전에 언급한 바 있는 메모리 안정성 버그들 중 하나이다. 메모리를 두번 해제 하는 것은 메모리 손상 (memory corruption)의 원인이 되는데, 이는 보안 취약성 문제를 일으킬 가능성이 있다.

</br>

메모리 안정성을 보장하기 위해서, 러스트는 이런 경우 어떤 일이 일어나는지 한가지 더 디테일이 있다. 

할당된 메모리를 복사하는 것을 시도하는 대신, 러스트에서는 s1이 더이상 유효하지 않다고 간주하고, 그러므로 러스트는 s1이 스코프 밖으로 벗어났을 때 아무것도 해제할 필요가 없어진다. 

s1을 s2가 만들어진 후에 사용하려고 할 때 어떤일이 벌어지는지 확인해 보면 러스트가 유효하지 않는 참조자를 사용하는 것을 막기 위해 에러를 발생시킨다.

</br>

<strong>FileName : 2장/ownership_task/src/main.rs</strong>

```rs
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);




❯ cargo run
   Compiling ownership_task v0.1.0 (/home/PromotionPawn/Project/Rust/2장/ownership_task)
warning: unused variable: `s2`
 --> src/main.rs:3:9
  |
3 |     let s2 = s1;
  |         ^^ help: if this is intentional, prefix it with an underscore: `_s2`
  |
  = note: `#[warn(unused_variables)]` on by default

error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
warning: `ownership_task` (bin "ownership_task") generated 1 warning
error: could not compile `ownership_task` due to previous error; 1 warning emitted

```

</br>

만약 다른 언어로 프로그래밍 하는 동안 얕은 복사와 깊은 복사 라는 용어를 들어 봤다면 데이터의 복사 없이 포인터와 길이값 및 용량값만 복사한다는 개념이 얕은 복사와 비슷하게 보일수도 있지만 러스트는 첫번째 변수를 무효화 시키기도 하기 때문에, 이를 얕은 복사 라고 부르는 대신 이동(move)라 말한다.

s1이 s2로 이동되었다 라고 말하는 식으로 위의 코드를 읽으면 된다.

</br>

이것이 아까 언급한 메모리 중복 해제 문제를 해결해 준다. 오직 s2만 유효한 상황에서, 스코프 밖으로 벗어나면 혼자 메모리를 해제할 것이다.

여기에 어해 이러한 경우가 함축하는 디자인 선택이 있는데 러스트는 결코 자동적으로 데이터에 대한 깊은 복사본을 만들지 않는다. 그러므로 자동적인 복사라도 런타임 실행 과정에서 효율적일 것이라 가정할 수 있다.






